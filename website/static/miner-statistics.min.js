/*! (c) Andrea Giammarchi - ISC */
var self=this||{};try{!function(t,n){if(new t("q=%2B").get("q")!==n||new t({q:n}).get("q")!==n||new t([["q",n]]).get("q")!==n||"q=%0A"!==new t("q=\n").toString()||"q=+%26"!==new t({q:" &"}).toString())throw t;self.URLSearchParams=t}(URLSearchParams,"+")}catch(t){!function(t,a,o){"use strict";var u=t.create,h=t.defineProperty,n=/[!'\(\)~]|%20|%00/g,e=/\+/g,r={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"},i={append:function(t,n){l(this._ungap,t,n)},delete:function(t){delete this._ungap[t]},get:function(t){return this.has(t)?this._ungap[t][0]:null},getAll:function(t){return this.has(t)?this._ungap[t].slice(0):[]},has:function(t){return t in this._ungap},set:function(t,n){this._ungap[t]=[a(n)]},forEach:function(n,e){var r=this;for(var i in r._ungap)r._ungap[i].forEach(t,i);function t(t){n.call(e,t,a(i),r)}},toJSON:function(){return{}},toString:function(){var t=[];for(var n in this._ungap)for(var e=g(n),r=0,i=this._ungap[n];r<i.length;r++)t.push(e+"="+g(i[r]));return t.join("&")}};for(var s in i)h(c.prototype,s,{configurable:!0,writable:!0,value:i[s]});function c(t){var n=u(null);switch(h(this,"_ungap",{value:n}),!0){case!t:break;case"string"==typeof t:"?"===t.charAt(0)&&(t=t.slice(1));for(var e=t.split("&"),r=0,i=e.length;r<i;r++){var a=(s=e[r]).indexOf("=");-1<a?l(n,p(s.slice(0,a)),p(s.slice(a+1))):s.length&&l(n,p(s),"")}break;case o(t):for(r=0,i=t.length;r<i;r++){var s;l(n,(s=t[r])[0],s[1])}break;case"forEach"in t:t.forEach(f,n);break;default:for(var c in t)l(n,c,t[c])}}function f(t,n){l(this,n,t)}function l(t,n,e){var r=o(e)?e.join(","):e;n in t?t[n].push(r):t[n]=[r]}function p(t){return decodeURIComponent(t.replace(e," "))}function g(t){return encodeURIComponent(t).replace(n,v)}function v(t){return r[t]}self.URLSearchParams=c}(Object,String,Array.isArray)}!function(l){var r=!1;try{r=!!Symbol.iterator}catch(t){}function t(t,n){var e=[];return t.forEach(n,e),r?e[Symbol.iterator]():{next:function(){var t=e.shift();return{done:void 0===t,value:t}}}}"forEach"in l||(l.forEach=function(e,r){var i=this,t=Object.create(null);this.toString().replace(/=[\s\S]*?(?:&|$)/g,"=").split("=").forEach(function(n){!n.length||n in t||(t[n]=i.getAll(n)).forEach(function(t){e.call(r,t,n,i)})})}),"keys"in l||(l.keys=function(){return t(this,function(t,n){this.push(n)})}),"values"in l||(l.values=function(){return t(this,function(t,n){this.push(t)})}),"entries"in l||(l.entries=function(){return t(this,function(t,n){this.push([n,t])})}),!r||Symbol.iterator in l||(l[Symbol.iterator]=l.entries),"sort"in l||(l.sort=function(){for(var t,n,e,r=this.entries(),i=r.next(),a=i.done,s=[],c=Object.create(null);!a;)n=(e=i.value)[0],s.push(n),n in c||(c[n]=[]),c[n].push(e[1]),a=(i=r.next()).done;for(s.sort(),t=0;t<s.length;t++)this.delete(s[t]);for(t=0;t<s.length;t++)n=s[t],this.append(n,c[n].shift())}),function(c){var o=c.defineProperty,u=c.getOwnPropertyDescriptor,h=function(t){var n=t.append;t.append=l.append,URLSearchParams.call(t,t._usp.search.slice(1)),t.append=n},f=function(t,n){if(!(t instanceof n))throw new TypeError("'searchParams' accessed on an object that does not implement interface "+n.name)},t=function(n){var e,r,t=n.prototype,i=u(t,"searchParams"),a=u(t,"href"),s=u(t,"search");!i&&s&&s.set&&(r=function(e){function r(t,n){l.append.call(this,t,n),t=this.toString(),e.set.call(this._usp,t?"?"+t:"")}function i(t){l.delete.call(this,t),t=this.toString(),e.set.call(this._usp,t?"?"+t:"")}function a(t,n){l.set.call(this,t,n),t=this.toString(),e.set.call(this._usp,t?"?"+t:"")}return function(t,n){return t.append=r,t.delete=i,t.set=a,o(t,"_usp",{configurable:!0,writable:!0,value:n})}}(s),e=function(t,n){return o(t,"_searchParams",{configurable:!0,writable:!0,value:r(n,t)}),n},c.defineProperties(t,{href:{get:function(){return a.get.call(this)},set:function(t){var n=this._searchParams;a.set.call(this,t),n&&h(n)}},search:{get:function(){return s.get.call(this)},set:function(t){var n=this._searchParams;s.set.call(this,t),n&&h(n)}},searchParams:{get:function(){return f(this,n),this._searchParams||e(this,new URLSearchParams(this.search.slice(1)))},set:function(t){f(this,n),e(this,t)}}}))};try{t(HTMLAnchorElement),/^function|object$/.test(typeof URL)&&URL.prototype&&t(URL)}catch(t){}}(Object)}(self.URLSearchParams.prototype,Object);

$(function(){
	var _miner = new URLSearchParams(window.location.search).get('address');
	$("#statsWorker").text(_miner);

	var _workerCount = 0;
	window.statsSource = new EventSource("/api/live_stats");

	var workerHashrateData;
	var workerHashrateChart;
	var workerHistoryMax = 160;

	var statData;
	var totalHash;
	var totalImmature;
	var totalBal;
	var totalPaid;
	var totalShares;

	function getReadableHashRateString(hashrate){
		hashrate = (hashrate * 2);
		if (hashrate < 1000000) {
			return (Math.round(hashrate / 1000) / 1000 ).toFixed(2)+' Sol/s';
		}
		var byteUnits = [ ' Sol/s', ' KSol/s', ' MSol/s', ' GSol/s', ' TSol/s', ' PSol/s' ];
		var i = Math.floor((Math.log(hashrate/1000) / Math.log(1000)) - 1);
		hashrate = (hashrate/1000) / Math.pow(1000, i + 1);
		return hashrate.toFixed(2) + byteUnits[i];
	}

	function timeOfDayFormat(timestamp){
		var dStr = d3.time.format('%I:%M %p')(new Date(timestamp));
		if (dStr.indexOf('0') === 0) dStr = dStr.slice(1);
		return dStr;
	}

	function getWorkerNameFromAddress(w) {
		var worker = w;
		if (w.split(".").length > 1) {
			worker = w.split(".")[1];
			if (worker == null || worker.length < 1) {
				worker = "noname";
			}
		} else {
			worker = "noname";
		}
		return worker;
	}

	function buildChartData(){
		var workers = {};
		for (var w in statData.history) {
			var worker = getWorkerNameFromAddress(w);
			var a = workers[worker] = (workers[worker] || {
				hashrate: []
			});
			for (var wh in statData.history[w]) {
				a.hashrate.push([statData.history[w][wh].time * 1000, statData.history[w][wh].hashrate]);
			}
			if (a.hashrate.length > workerHistoryMax) {
				workerHistoryMax = a.hashrate.length;
			}
		}
		
		var i=0;
		workerHashrateData = [];
		for (var worker in workers){
			workerHashrateData.push({
				key: worker,
				disabled: (i > Math.min((_workerCount-1), 3)),
				values: workers[worker].hashrate
			});
			i++;
		}
	}

	function updateChartData(){
		var workers = {};
		for (var w in statData.history) {
			var worker = getWorkerNameFromAddress(w);
			// get a reference to lastest workerhistory
			for (var wh in statData.history[w]) { }
			//var wh = statData.history[w][statData.history[w].length - 1];
			var foundWorker = false;
			for (var i = 0; i < workerHashrateData.length; i++) {
				if (workerHashrateData[i].key === worker) {
					foundWorker = true;
					if (workerHashrateData[i].values.length >= workerHistoryMax) {
						workerHashrateData[i].values.shift();
					}
					workerHashrateData[i].values.push([statData.history[w][wh].time * 1000, statData.history[w][wh].hashrate]);
					break;
				}
			}
			if (!foundWorker) {
				var hashrate = [];
				hashrate.push([statData.history[w][wh].time * 1000, statData.history[w][wh].hashrate]);
				workerHashrateData.push({
					key: worker,
					values: hashrate
				});
				rebuildWorkerDisplay();
				return true;
			}
		}
		triggerChartUpdates();
		return false;
	}

	function calculateAverageHashrate(worker) {
		var count = 0;
		var total = 1;
		var avg = 0;
		for (var i = 0; i < workerHashrateData.length; i++) {
			count = 0;
			for (var ii = 0; ii < workerHashrateData[i].values.length; ii++) {
				if (worker == null || workerHashrateData[i].key === worker) {
					count++;
					avg += parseFloat(workerHashrateData[i].values[ii][1]);
				}
			}
			if (count > total)
				total = count;
		}
		avg = avg / total;
		return avg;
	}

	function triggerChartUpdates(){
		workerHashrateChart.update();
	}

	function displayCharts() {
		nv.addGraph(function() {
			workerHashrateChart = nv.models.lineChart()
				.margin({left: 80, right: 30})
				.x(function(d){ return d[0] })
				.y(function(d){ return d[1] })
				.useInteractiveGuideline(true);

			workerHashrateChart.xAxis.tickFormat(timeOfDayFormat);

			workerHashrateChart.yAxis.tickFormat(function(d){
				return getReadableHashRateString(d);
			});
			d3.select('#workerHashrate').datum(workerHashrateData).call(workerHashrateChart);
			return workerHashrateChart;
		});
	}

	function updateStats() {
		totalHash = statData.totalHash;
		totalPaid = statData.paid;
		totalBal = statData.balance;
		totalImmature = statData.immature;
		totalShares = statData.totalShares;
		// do some calculations
		var _blocktime = 250;
		var _networkHashRate = parseFloat(statData.networkSols) * 1.2;
		var _myHashRate = (totalHash / 1000000) * 2;
		var luckDays =  ((_networkHashRate / _myHashRate * _blocktime) / (24 * 60 * 60)).toFixed(3);
		// update miner stats
		$("#statsHashrate").text(getReadableHashRateString(totalHash));
		$("#statsHashrateAvg").text(getReadableHashRateString(calculateAverageHashrate(null)));
		$("#statsLuckDays").text(luckDays);
		$("#statsTotalImmature").text(totalImmature);
		$("#statsTotalBal").text(totalBal);
		$("#statsTotalPaid").text(totalPaid);
		$("#statsTotalShares").text(totalShares.toFixed(2));
	}
	function updateWorkerStats() {
		// update worker stats
		var i=0;
		for (var w in statData.workers) { i++;
			var htmlSafeWorkerName = w.split('.').join('_').replace(/[^\w\s]/gi, '');
			var saneWorkerName = getWorkerNameFromAddress(w);
			$("#statsHashrate"+htmlSafeWorkerName).text(getReadableHashRateString(statData.workers[w].hashrate));
			$("#statsHashrateAvg"+htmlSafeWorkerName).text(getReadableHashRateString(calculateAverageHashrate(saneWorkerName)));
			$("#statsLuckDays"+htmlSafeWorkerName).text(statData.workers[w].luckDays);
			$("#statsPaid"+htmlSafeWorkerName).text(statData.workers[w].paid);
			$("#statsBalance"+htmlSafeWorkerName).text(statData.workers[w].balance);
			$("#statsShares"+htmlSafeWorkerName).text(Math.round(statData.workers[w].currRoundShares * 100) / 100);
			$("#statsDiff"+htmlSafeWorkerName).text(statData.workers[w].diff);
		}
	}
	function addWorkerToDisplay(name, htmlSafeName, workerObj) {
		var htmlToAdd = "";
		htmlToAdd = '<div class="boxStats" id="boxStatsLeft" style="float:left; margin: 9px; min-width: 260px;"><div class="boxStatsList">';
		if (htmlSafeName.indexOf("_") >= 0) {
			htmlToAdd+= '<div class="boxLowerHeader">'+htmlSafeName.substr(htmlSafeName.indexOf("_")+1,htmlSafeName.length)+'</div>';
		} else {
			htmlToAdd+= '<div class="boxLowerHeader">noname</div>';
		}
		htmlToAdd+='<div><i class="fa fa-tachometer"></i> <span id="statsHashrate'+htmlSafeName+'">'+getReadableHashRateString(workerObj.hashrate)+'</span> (Now)</div>';
		htmlToAdd+='<div><i class="fa fa-tachometer"></i> <span id="statsHashrateAvg'+htmlSafeName+'">'+getReadableHashRateString(calculateAverageHashrate(name))+'</span> (Avg)</div>';
		htmlToAdd+='<div><i class="fa fa-shield"></i> <small>Diff:</small> <span id="statsDiff'+htmlSafeName+'">'+workerObj.diff+'</span></div>';
		htmlToAdd+='<div><i class="fa fa-cog"></i> <small>Shares:</small> <span id="statsShares'+htmlSafeName+'">'+(Math.round(workerObj.currRoundShares * 100) / 100)+'</span></div>';
		htmlToAdd+='<div><i class="fa fa-gavel"></i> <small>Luck <span id="statsLuckDays'+htmlSafeName+'">'+workerObj.luckDays+'</span> Days</small></div>';
		htmlToAdd+='<div><i class="fa fa-money"></i> <small>Bal: <span id="statsBalance'+htmlSafeName+'">'+workerObj.balance+'</span></small></div>';
		htmlToAdd+='<div><i class="fa fa-money"></i> <small>Paid: <span id="statsPaid'+htmlSafeName+'">'+workerObj.paid+'</span></small></div>';
		htmlToAdd+='</div></div></div>';
		$("#boxesWorkers").html($("#boxesWorkers").html()+htmlToAdd);
	}

	function rebuildWorkerDisplay() {
		$("#boxesWorkers").html("");
		var i=0;
		for (var w in statData.workers) { i++;
			var htmlSafeWorkerName = w.split('.').join('_').replace(/[^\w\s]/gi, '');
			var saneWorkerName = getWorkerNameFromAddress(w);
			addWorkerToDisplay(saneWorkerName, htmlSafeWorkerName, statData.workers[w]);
		}
	}

	// resize chart on window resize
	nv.utils.windowResize(triggerChartUpdates);

	// grab initial stats
	$.getJSON('/api/worker_stats?'+_miner, function(data){
		statData = data;
		for (var w in statData.workers) { _workerCount++; }
		buildChartData();
		displayCharts();
		rebuildWorkerDisplay();	
		updateStats();
	});

	// live stat updates
	statsSource.addEventListener('message', function(e){
		// TODO, create miner_live_stats...
		// miner_live_stats will return the same josn except without the worker history
		// FOR NOW, use this to grab updated stats
		$.getJSON('/api/worker_stats?'+_miner, function(data){
			statData = data;
			// check for missing workers
			var wc = 0;
			var rebuilt = false;
			// update worker stats
			for (var w in statData.workers) { wc++; }
			// TODO, this isn't 100% fool proof!
			if (_workerCount != wc) {
				if (_workerCount > wc) {
					rebuildWorkerDisplay();
					rebuilt = true;
				}
				_workerCount = wc;
			}
			rebuilt = (rebuilt || updateChartData());
			updateStats();
			if (!rebuilt) {
				updateWorkerStats();
			}
		});
	});
});
